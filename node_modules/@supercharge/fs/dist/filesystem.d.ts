/// <reference types="node" />
import Fs, { PathLike, SymlinkType, WriteFileOptions } from 'fs-extra';
import Lockfile from 'proper-lockfile';
declare const _default: typeof Fs & {
    /**
     * Returns the file size in bytes of the file located at `path`.
     *
     * @param {String} path
     *
     * @returns {Integer}
     */
    size(path: string): Promise<number>;
    /**
     * Retrieve the time when `file` was last modified.
     *
     * @param {String} file
     *
     * @returns {Date}
     */
    lastModified(file: string): Promise<Date>;
    /**
     * Retrieve the time when `file` was last accessed.
     *
     * @param {String} file
     *
     * @returns {Date}
     */
    lastAccessed(file: string): Promise<Date>;
    /**
     * Change the file system timestamps of the
     * referenced `path`. Updates the last
     * accessed and last modified properties.
     *
     * @param {String} path
     * @param {Number} lastAccessed
     * @param {Number} lastModified
     *
     * @throws
     */
    updateTimestamps(path: string, lastAccessed: Date, lastModified: Date): Promise<void>;
    /**
     * Test the user's permissions for the given `path` which can
     * be a file or directory. The `mode` argument is an optional
     * integer to specify the accessibility level.
     *
     * @param {String} path  - file or directory path
     * @param {Integer} mode - defaults to `fs.constants.F_OK`
     *
     * @returns {Boolean}
     *
     * @throws
     */
    canAccess(path: string, mode?: number): Promise<boolean>;
    /**
     * Shortcut for `pathExists` determining whether a given file or
     * directory exists at the given `path` on the file system.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    exists(path: string): Promise<boolean>;
    /**
     * Determine wether the given `path` does not exists.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    notExists(path: string): Promise<boolean>;
    /**
     * Updates the access and modification times of the given `file` current
     * time. This method creates the `file` if it doesn’t exist.
     *
     * @param {String} file
     */
    touch(file: string): Promise<void>;
    /**
     * Read the entire content of `file`. If no `encoding` is
     * specified, the raw buffer is returned. If `encoding` is
     * an object, it allows the `encoding` and `flag` options.
     *
     * @param {String} file
     * @param {String|Object} encoding
     *
     * @returns {String}
     */
    readFile(file: string, encoding?: string | undefined): Promise<string>;
    /**
     * Returns the content of the given `file` as a string.
     *
     * @param {String} file
     *
     * @returns {String}
     */
    content(file: string): Promise<string>;
    /**
     * Returns an array of file names containing the files that are available
     * in the given directory `path`. This method excludes the paths `.` and
     * `..` and does not read files recursively in available subdirectories.
     *
     * @param {String} path
     *
     * @returns {Array}
     */
    files(path: string): Promise<string[]>;
    /**
     * Returns an array of file names of all files, even recursive files in the given
     * directory `path`.  This method excludes the paths `.`, `..`, and dotfiles.
     *
     * @param {String} path
     * @param {ReadFileOptions} options
     *
     * @returns {Array}
     */
    allFiles(path: string, options?: ReadFileOptions | undefined): Promise<string[]>;
    /**
     * Write the given `content` to the file` and create
     * any parent directories if not existent.
     *
     * @param  {String} path
     * @param  {String} content
     * @param  {WriteFileOptions} options
     */
    writeFile(file: string, content: string, options: WriteFileOptions): Promise<void>;
    /**
     * Removes a `file` from the file system.
     *
     * @param {String} file
     */
    removeFile(file: string): Promise<void>;
    /**
     * Ensures that the directory exists. If the directory
     * structure does not exist, it is created.
     * Like `mkdir -p`.
     *
     * @param {String} dir - directory path
     *
     * @returns {String} dir - directory path
     */
    ensureDir(dir: string): Promise<string>;
    /**
     * Removes a `dir` from the file system.The directory
     * can have content. Content in the directory will
     * be removed as well, like `rm -rf`.
     *
     * @param {String} dir - directory path
     */
    removeDir(dir: string): Promise<void>;
    /**
     * Changes the permissions of a `file`.
     * The `mode` is a numeric bitmask and
     * can be an integer or string.
     *
     * @param {String} file
     * @param {String|Integer} mode
     */
    chmod(file: string, mode: string): Promise<void>;
    /**
     * Ensures that the symlink from source to
     * destination exists. If the directory
     * structure does not exist, it is created.
     *
     * @param {String} src
     * @param {String} dest
     * @param {String} type
     */
    ensureSymlink(src: string, dest: string, type?: SymlinkType): Promise<void>;
    /**
     * Acquire a file lock on the specified `file` path with the given `options`.
     * If the `file` is already locked, this method won't throw an error and
     * instead just move on.
     *
     * @param {String} file
     * @param {Object} options
     *
     * @returns {Function} release function
     */
    lock(file: string, options?: Lockfile.LockOptions | undefined): Promise<void>;
    /**
     * Release an existent lock for the `file` and given `options`. If the `file`
     * isn't locked, this method won't throw an error and just move on.
     *
     * @param {String} file
     */
    unlock(file: string, options?: Lockfile.UnlockOptions | undefined): Promise<void>;
    /**
     * Check if the `file` is locked and not stale.
     *
     * @param {String} file
     * @param {Object} options
     *
     * @returns {Boolean}
     */
    isLocked(file: string, options?: Lockfile.CheckOptions | undefined): Promise<boolean>;
    /**
     * Check if the `file` is not locked and not stale.
     *
     * @param {String} file
     * @param {Object} options
     *
     * @returns {Boolean}
     */
    isNotLocked(file: string, options?: Lockfile.CheckOptions | undefined): Promise<boolean>;
    /**
     * Create a random temporary file path you can write to.
     * The operating system will clean up the temporary
     * files automatically, probably after some days.
     *
     * @param {Object} options
     *
     * @returns {String}
     */
    tempFile(name?: string | undefined): Promise<string>;
    /**
     * Create a temporary directory path which will be cleaned up by the operating system.
     *
     * @returns {String}
     */
    tempDir(): Promise<string>;
    /**
     * Returns the path to the user’s home directory. You may pass a `path` to which
     * the function should resolve in the user’s home directory. This method does
     * **not** ensure that the resolved path exists. Please do that yourself.
     *
     * @param {String} path
     *
     * @returns {String}
     */
    homeDir(path?: string | undefined): string;
    /**
     * Generates a random, temporary path on the filesystem.
     *
     * @returns {String}
     */
    tempPath(): Promise<string>;
    /**
     * Returns the fully resolve, absolute file path to the given `path`.
     * Resolves any relative paths, like `..` or `.`, and symbolic links.
     *
     * @param {String} path
     * @param {Object} cache
     *
     * @returns {String}
     */
    realPath(path: string, cache?: {
        [path: string]: string;
    } | undefined): Promise<string>;
    /**
     * Returns the extension of `file`. For example, returns `.html`
     * for the HTML file located at `/path/to/index.html`.
     *
     * @param {String} file
     *
     * @returns {String}
     */
    extension(file: string): string;
    /**
     * Returns the trailing name component from a file path. For example,
     * returns `file.png` from the path `/home/user/file.png`.
     *
     * @param {String} path
     * @param {String} extension
     *
     * @returns {String}
     */
    basename(path: string, extension: string): string;
    /**
     * Returns the file name without extension.
     *
     * @param {String} file
     *
     * @returns {String}
     */
    filename(file: string): string;
    /**
     * Returns the directory name of the given `path`.
     * For example, a file path of `foo/bar/baz/file.txt`
     * returns `foo/bar/baz`.
     *
     * @param {String} path
     *
     * @returns {String}
     */
    dirname(path: string): string;
    /**
     * Determine whether the given `path` is a file.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    isFile(path: string): Promise<boolean>;
    /**
     * Determine whether the given `path` is a directory.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    isDirectory(path: string): Promise<boolean>;
    /**
     * Determine whether a the given `path` is a socket.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    isSocket(path: string): Promise<boolean>;
    /**
     * Determine whether a the given `path` is a symbolic link.
     *
     * @param {PathLike} path
     *
     * @returns {Boolean}
     */
    isSymLink(path: string): Promise<boolean>;
    /**
     * Append the given `content` to a `file`. This method
     * creates the `file` if it does not exist yet.
     *
     * @param {PathLike} file
     * @param {String|Buffer} content
     * @param {String|Object} options
     */
    append(file: PathLike | number, content: string | Buffer, options?: AppendOptions | undefined): Promise<void>;
    /**
     * Append the given `content` in a new line to the given `file`.
     * This method creates the `file` if it does not exist yet.
     *
     * @param {PathLike} file
     * @param {String|Buffer} content
     * @param {String|Object} options
     */
    appendLine(file: PathLike | number, content: string | Buffer, options?: AppendOptions | undefined): Promise<void>;
    /**
     * Determine whether the given `path` points to an empty directory. In comparison to the
     * `Fs.emptyDir(path)` method, this `Fs.isEmptyDir(path)` method doesn’t load all files
     * into memory. It opens the folder as a stream and checks if at least one file exists.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    isEmptyDir(path: string): Promise<boolean>;
};
export default _default;
export interface AppendOptions {
    encoding?: string;
    mode?: number | string;
    flag?: string;
}
export declare type IgnoreFileCallback = (file: string, stats: Fs.Stats) => boolean;
export interface ReadFileOptions {
    ignore: string | string[] | IgnoreFileCallback | IgnoreFileCallback[];
}
